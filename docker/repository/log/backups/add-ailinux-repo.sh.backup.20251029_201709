#!/usr/bin/env bash
# =====================================================================
#  AILinux Repository Bootstrap (Deb822, noble/24.04 FULL amd64+i386)
#  - Ubuntu FULL: main+restricted+universe+multiverse (amd64+i386)
#  - Zusatzquellen (Neon, Xubuntu Staging, Cappelikan, LibreOffice, Docker, Chrome, WineHQ)
#  - AILinux Branding (add-apt-repository-kompatibel: ID=ubuntu, DISTRIB_ID=Ubuntu)
#
#  Optionen:
#    --dry-run      : nur anzeigen, nichts schreiben
#    --remove       : alle von diesem Script erstellten Quellen + Key + Branding entfernen
#    --no-branding  : Branding überspringen (Standard: Branding aktiv)
# =====================================================================

set -euo pipefail

# -------------------------- Konfiguration ----------------------------
REPO_DOMAIN_URL="${REPO_DOMAIN_URL:-https://repo.ailinux.me:8443}"
REPO_BASE_URL="${REPO_BASE_URL:-${REPO_DOMAIN_URL}/mirror}"

# Ein lokaler Key für alle gespiegelten Quellen (du re-signst Releases)
KEY_URL="${KEY_URL:-${REPO_BASE_URL}/ailinux-archive-key.gpg}"
KEYRING_DEST="${KEYRING_DEST:-/usr/share/keyrings/ailinux-archive-keyring.gpg}"

CODENAME="$(. /etc/os-release 2>/dev/null && echo "${VERSION_CODENAME:-noble}")"
[[ -z "${CODENAME}" ]] && CODENAME="noble"

# Ubuntu-Basis (FULL)
UBUNTU_SUITES="${CODENAME} ${CODENAME}-updates ${CODENAME}-backports"  # security has its own source
# Für Wine/Steam wird multiarch verwendet (amd64 mit i386-Libs), nicht separate i386-Repos.
UBUNTU_COMPONENTS="main restricted universe multiverse"
# Für Wine/Steam wird multiarch verwendet (amd64 mit i386-Libs), nicht separate i386-Repos.
# NOTE: Ubuntu Noble (24.04) hat praktisch keine i386-Repos mehr.
# Für Wine/Steam wird multiarch verwendet (amd64 mit i386-Libs), nicht separate i386-Repos.
UBUNTU_ARCHS="amd64"
# Für Wine/Steam wird multiarch verwendet (amd64 mit i386-Libs), nicht separate i386-Repos.

# Architekturen je Zusatzquelle (nur amd64 für Noble)
NEON_ARCHS="amd64"
XUBUNTU_ARCHS="amd64"
CAPPELIKAN_ARCHS="amd64"
LIBREOFFICE_ARCHS="amd64"
DOCKER_ARCHS="amd64"
CHROME_ARCHS="amd64"
WINE_ARCHS="amd64"

# Deb822-Ziele (.sources)
D="/etc/apt/sources.list.d"
F_UBU="${D}/ailinux-ubuntu.sources"
F_SEC="${D}/ailinux-ubuntu-security.sources"
F_NEON="${D}/ailinux-neon.sources"
F_XFCE="${D}/ailinux-xubuntu-staging.sources"
F_CAPL="${D}/ailinux-cappelikan.sources"
F_LO="${D}/ailinux-libreoffice.sources"
F_DOCK="${D}/ailinux-docker.sources"
F_CHRM="${D}/ailinux-chrome.sources"
F_WINE="${D}/ailinux-winehq.sources"

# Gespiegelte URIs auf DEINEM Server
URI_UBU="${REPO_BASE_URL}/archive.ubuntu.com/ubuntu"
URI_SEC="${REPO_BASE_URL}/security.ubuntu.com/ubuntu"
URI_NEON="${REPO_BASE_URL}/archive.neon.kde.org/user"
URI_XFCE="${REPO_BASE_URL}/ppa.launchpadcontent.net/xubuntu-dev/staging/ubuntu"
URI_CAPL="${REPO_BASE_URL}/ppa.launchpadcontent.net/cappelikan/ppa/ubuntu"
URI_LO="${REPO_BASE_URL}/ppa.launchpadcontent.net/libreoffice/ppa/ubuntu"
URI_DOCK="${REPO_BASE_URL}/download.docker.com/linux/ubuntu"
URI_CHRM="${REPO_BASE_URL}/dl.google.com/linux/chrome/deb"
URI_WINE="${REPO_BASE_URL}/dl.winehq.org/wine-builds/ubuntu"

# Branding
BRANDING_SCRIPT="/usr/local/sbin/ailinux-branding.sh"
BRANDING_SERVICE="/etc/systemd/system/ailinux-branding.service"
DO_BRANDING=true

# -------------------------- Optionen/Flags ---------------------------
DRY_RUN=false
DO_REMOVE=false
for arg in "$@"; do
  case "$arg" in
    --dry-run)      DRY_RUN=true ;;
    --remove)       DO_REMOVE=true ;;
    --no-branding)  DO_BRANDING=false ;;
    *) echo "Unbekannte Option: $arg"; echo "Verwendung: $0 [--dry-run] [--remove] [--no-branding]"; exit 2 ;;
  esac
done

# ----------------------------- Helpers -------------------------------
need_root() { if [[ $EUID -ne 0 ]]; then echo "Bitte als root ausführen (sudo $0 …)"; exit 1; fi; }
msg(){ printf "%s\n" "$*"; }

write_file(){ # write_file <path> <mode> <<<"content"
  local path="$1" mode="$2"
  if $DRY_RUN; then
    echo "DRY-RUN: würde schreiben: $path (chmod $mode)"; sed 's/^/| /'
  else
    install -Dm"$mode" /dev/stdin "$path"
    echo "Geschrieben: $path"
  fi
}

backup_and_rm(){ # backup_and_rm <file>
  local f="$1"; [[ -e "$f" ]] || return 0
  local dir="/var/backups/ailinux-repo"; mkdir -p "$dir"
  cp -a "$f" "$dir/$(basename "$f").$(date +%Y%m%d-%H%M%S).bak" || true
  $DRY_RUN && echo "DRY-RUN: würde löschen: $f" || rm -f "$f"
}

install_key(){
  msg "-> Lade Schlüssel: $KEY_URL"
  if $DRY_RUN; then
    echo "DRY-RUN: würde nach $KEYRING_DEST installieren"
    return 0
  fi
  curl -fsSL "$KEY_URL" -o /tmp/ailinux-key.gpg
  install -Dm0644 /tmp/ailinux-key.gpg "$KEYRING_DEST"
  rm -f /tmp/ailinux-key.gpg
  echo "Installiert: $KEYRING_DEST"
}

apt_update(){
  $DRY_RUN && echo "DRY-RUN: würde 'apt update' ausführen" || apt update
}

# ----------------------------- BRANDING -------------------------------
install_branding_assets(){
  # add-apt-repository-kompatibel:
  #  - /etc/os-release: ID=ubuntu, UBUNTU_CODENAME=noble
  #  - /etc/lsb-release: DISTRIB_ID=Ubuntu, … (mit AILinux-Branding in PRETTY-NAME/Beschreibung)
  cat <<'EOS' | write_file "$BRANDING_SCRIPT" 0755
#!/usr/bin/env bash
set -euo pipefail

OS_RELEASE="/etc/os-release"
LSB_RELEASE="/etc/lsb-release"

cat >"$OS_RELEASE" <<'EOF'
NAME="AILinux"
PRETTY_NAME="AILinux (Ubuntu 24.04 Noble Base)"
ID=ubuntu
ID_LIKE=debian
VERSION_ID="24.04"
VERSION_CODENAME=noble
UBUNTU_CODENAME=noble
HOME_URL="https://ailinux.me"
SUPPORT_URL="https://forum.ailinux.me"
BUG_REPORT_URL="https://github.com/derleiti/ailinux-repo/issues"
EOF

cat >"$LSB_RELEASE" <<'EOF'
DISTRIB_ID=Ubuntu
DISTRIB_RELEASE=24.04
DISTRIB_CODENAME=noble
DISTRIB_DESCRIPTION="AILinux (Ubuntu 24.04 Noble Base)"
EOF

echo "AILinux-Branding aktualisiert: $OS_RELEASE & $LSB_RELEASE"
EOS

  cat <<'EOF' | write_file "$BRANDING_SERVICE" 0644
[Unit]
Description=AILinux Branding Writer (os-release & lsb-release)
After=local-fs.target
ConditionPathExists=/usr/local/sbin/ailinux-branding.sh

[Service]
Type=oneshot
ExecStart=/usr/local/sbin/ailinux-branding.sh
RemainAfterExit=yes

[Install]
WantedBy=multi-user.target
EOF

  if $DRY_RUN; then
    echo "DRY-RUN: würde 'systemctl daemon-reload && systemctl enable --now ailinux-branding.service' ausführen."
  else
    systemctl daemon-reload
    systemctl enable --now ailinux-branding.service
    echo "Branding-Dienst aktiviert und ausgeführt: ailinux-branding.service"
  fi
}

remove_branding_assets(){
  if $DRY_RUN; then
    echo "DRY-RUN: würde Branding entfernen: $BRANDING_SERVICE $BRANDING_SCRIPT"
  else
    systemctl disable --now ailinux-branding.service 2>/dev/null || true
    rm -f "$BRANDING_SERVICE" "$BRANDING_SCRIPT"
    systemctl daemon-reload
    echo "Branding entfernt."
  fi
}

# ----------------------------- REMOVE --------------------------------
do_remove(){
  msg "Entferne AILinux .sources & Keyring…"
  for f in \
    "$F_UBU" "$F_SEC" "$F_NEON" "$F_XFCE" "$F_CAPL" "$F_LO" "$F_DOCK" "$F_CHRM" "$F_WINE"
  do
    backup_and_rm "$f"
  done
  backup_and_rm "$KEYRING_DEST"
  remove_branding_assets
  apt_update
  echo "Fertig (REMOVE)."
}

# ---------------------------- ADD/UPDATE ------------------------------
write_ubuntu_sources(){
  # Hauptarchiv (FULL)
  {
    echo "Types: deb"
    echo "URIs: ${URI_UBU}"
    echo "Suites: ${UBUNTU_SUITES}"
    echo "Components: ${UBUNTU_COMPONENTS}"
    [[ -n "${UBUNTU_ARCHS}" ]] && echo "Architectures: ${UBUNTU_ARCHS}"
    echo "Signed-By: ${KEYRING_DEST}"
  } | write_file "$F_UBU" 0644

  # Security-Archiv getrennt (klarere Trennung)
  {
    echo "Types: deb"
    echo "URIs: ${URI_SEC}"
    echo "Suites: ${CODENAME}-security"
    echo "Components: ${UBUNTU_COMPONENTS}"
    [[ -n "${UBUNTU_ARCHS}" ]] && echo "Architectures: ${UBUNTU_ARCHS}"
    echo "Signed-By: ${KEYRING_DEST}"
  } | write_file "$F_SEC" 0644
}

write_neon(){
  {
    echo "Types: deb"
    echo "URIs: ${URI_NEON}"
    echo "Suites: ${CODENAME}"
    echo "Components: main"
    [[ -n "${NEON_ARCHS}" ]] && echo "Architectures: ${NEON_ARCHS}"
    echo "Signed-By: ${KEYRING_DEST}"
  } | write_file "$F_NEON" 0644
}

write_xubuntu_staging(){
  {
    echo "Types: deb"
    echo "URIs: ${URI_XFCE}"
    echo "Suites: ${CODENAME}"
    echo "Components: main"
    [[ -n "${XUBUNTU_ARCHS}" ]] && echo "Architectures: ${XUBUNTU_ARCHS}"
    echo "Signed-By: ${KEYRING_DEST}"
  } | write_file "$F_XFCE" 0644
}

write_cappelikan(){
  {
    echo "Types: deb"
    echo "URIs: ${URI_CAPL}"
    echo "Suites: ${CODENAME}"
    echo "Components: main"
    [[ -n "${CAPPELIKAN_ARCHS}" ]] && echo "Architectures: ${CAPPELIKAN_ARCHS}"
    echo "Signed-By: ${KEYRING_DEST}"
  } | write_file "$F_CAPL" 0644
}

write_libreoffice(){
  {
    echo "Types: deb"
    echo "URIs: ${URI_LO}"
    echo "Suites: ${CODENAME}"
    echo "Components: main"
    [[ -n "${LIBREOFFICE_ARCHS}" ]] && echo "Architectures: ${LIBREOFFICE_ARCHS}"
    echo "Signed-By: ${KEYRING_DEST}"
  } | write_file "$F_LO" 0644
}

write_docker(){
  {
    echo "Types: deb"
    echo "URIs: ${URI_DOCK}"
    echo "Suites: ${CODENAME}"
    echo "Components: stable"
    [[ -n "${DOCKER_ARCHS}" ]] && echo "Architectures: ${DOCKER_ARCHS}"
    echo "Signed-By: ${KEYRING_DEST}"
  } | write_file "$F_DOCK" 0644
}

write_chrome(){
  {
    echo "Types: deb"
    echo "URIs: ${URI_CHRM}"
    echo "Suites: stable"
    echo "Components: main"
    [[ -n "${CHROME_ARCHS}" ]] && echo "Architectures: ${CHROME_ARCHS}"
    echo "Signed-By: ${KEYRING_DEST}"
  } | write_file "$F_CHRM" 0644
}

write_winehq(){
  {
    echo "Types: deb"
    echo "URIs: ${URI_WINE}"
    echo "Suites: ${CODENAME}"
    echo "Components: main"
    [[ -n "${WINE_ARCHS}" ]] && echo "Architectures: ${WINE_ARCHS}"
    echo "Signed-By: ${KEYRING_DEST}"
  } | write_file "$F_WINE" 0644
}

# ----------------------------- Ablauf --------------------------------
need_root
echo "===[ AILinux Repo Bootstrap ]==============================="
echo "Base URL  : $REPO_BASE_URL"
echo "Codename  : $CODENAME"
echo "Archs     : amd64 + i386 (für multiverse und Wine/Steam Kompatibilität)"
echo "Keyring   : $KEYRING_DEST"
echo "Dry-Run   : $DRY_RUN"
echo "Operation : $([[ $DO_REMOVE == true ]] && echo REMOVE || echo ADD/UPDATE)"
echo "Branding  : $([[ $DO_BRANDING == true ]] && echo aktiv || echo deaktiviert)"
echo "============================================================"

$DO_REMOVE && { do_remove; exit 0; }

# 1) Key
install_key
# 1b) Branding (standardmäßig aktiv)
if $DO_BRANDING; then install_branding_assets; else echo "Branding übersprungen (--no-branding)."; fi

# 2) Quellen schreiben (entsprechend deiner FULL mirror.list)
write_ubuntu_sources
write_neon
write_xubuntu_staging
write_cappelikan
write_libreoffice
write_docker
write_chrome
write_winehq

# 3) Update
apt_update

echo "Fertig. AILinux-Quellen + Branding sind eingerichtet."
echo "Tipp: Branding neu anwenden: systemctl start ailinux-branding.service"
# =====================================================================
